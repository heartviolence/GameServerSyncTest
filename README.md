# 프로젝트를 시작한 이유

공부용 토이 프로젝트,

Battlerite같은 게임과 유사한 시스템을 만드는게 목적

## Tcp Udp

https://stackoverflow.com/questions/47903/udp-vs-tcp-how-much-faster-is-it

TCP는 패킷유실을 허용하지 않기때문에 재전송대기시간의 타임래그가 실시간 게임에 적합하지 않은 경우가 있다.

실제로 실시간 게임서버에 UDP를 사용하는 경우가 많다고한다.

UDP프로토콜을 사용해 본 경험이 없기도하고, Battlerite같은 게임에 UDP가 적합해 보여서 UDP를 사용하기로 했다.

TCP대신에 UDP를 사용하는것은 여러 불편함을 초래하기도 하니, 실제 상용게임을 만드는 경우에는 예상 시나리오를 실험하고 분석하여 신중히 결정 해야할 것이다.

## LiteNetLib

프로젝트에서 사용한 Reliable UDP 라이브러리.

Unity에서 사용할 수 있는 UDP라이브러리를 검색하여 그 중에서 적당히 골랐다.

채택한 이유로는 예시 프로젝트가 있었고,사용하기 쉬워보였고 ,git star가 많았다.

튜토리얼 덕분에 기본적인 틀을 잡기는 편했다.

## MessagePack

LiteNetLib이 기본적으로 제공하는 유틸 툴이 사용하기 번거롭기에 직렬화 라이브러리를 추가했다.

LiteNetLib은 주로 직렬화관련 코드를 직접 작성해야하는 부분이 번거롭고, 사양 변경시 누락부분이 생길 수 있다.

보내는 메시지는 최소화하고, 내부 데이터는 직렬화,역직렬화 하기로 했다.

## 서버-클라이언트 동기화 시나리오

서버가 데이터를 주기적으로 전송하여 클라이언트가 업데이트 하는 식의 방식을 먼저 고려했으나.

매 프레임 서버가 많은량의 데이터는 브로드캐스팅 하는것은 서버에 부담이 된다고 생각했기에 다른방식을 채택하였다.
<br />
<br />
<br />
프로젝트에서 사용한 방식은 서버와 클라이언트가 같은 로직으로 서로 시뮬레이션하고, 시뮬레이션에 들어가는 입력만을 동기화한다.

서버는 클라이언트 입력을 취합하고, Unity Update Loop를 통해 시뮬레이션한다. 그 후 시뮬레이션에 사용한 입력과 월드 시간을 브로드캐스팅하면

클라이언트는 받은 정보를 토대로 서버와 똑같이 시뮬레이트한다. 결정적 로직을 사용할 경우 서버와 클라이언트는 동일한 결과값을 가지게 될것이다.
<br />
<br />
<br />
이론상으론 문제 없어보이고 모든 동기화 오브젝트를 보내는것보다 전송량도 줄일 수 있다고 생각했지만 몇가지 단점이 존재했다.

작성한 로직이 결정적인가를 확인하고 테스트하는데 어려움이 있다. 특히 외부 라이브러리를 사용할 때 같은 조건에서 같은 결과를 내는지 일일이 코드를 확인하기도 어렵고 애초에 확인이 불가능할 수 있다.

그리고 시뮬레이션시 결과가 달라져도 무엇이 원인으로 시뮬레이션 결과가 달라졌는지 확인하기 어렵다. 

하지만 '동기화 오브젝트의 데이터가 큰 경우'에는 전송량에서 이점을 볼 수 있다고 생각한다.

## 몇가지 핵심클래스들

## EntryPoint

게임로직의 진입점이다. 에셋을 로드하고,필요한 클래스들을 초기화한다음 로직을 시작한다.

게임에 필요한 에셋이 무엇인지는 게임 시작전에 결정되는 경우가 많기에 어떤 데이터를 로드해야하는지를 알려준다면 미리 로드할 데이터를 줄일 수 있다.

동기화 여부를 눈으로 확인하기 위해 클라이언트-서버 애플리케이션을 분리하지않았다. 서버,클라이언트1,클라이언트2 업데이트전에 전역변수를 갱신한다. 

로직코드는 전역변수를 통해 올바른 값을 참조한다.

## ClientBehaviour,ServerBehaviour 

통신을 담당하는 클래스. 

주고받은 데이터를 통해 World에 이벤트를 삽입하며 동기화한다.

서버가 클라이언트에게 브로드캐스팅하는 정보는 Reliable전송을 사용하여 TCP와 비슷한 원리로 데이터를 전송한다.

## ServerWorldStates

동기화될 게임데이터들을 모아둔 클래스. Actor들의 추가,삭제,이벤트루프등을 실행시킨다.

## Actor

게임내 동기화할 오브젝트들의 base 클래스

기본적으로 data와 gameObject를 둘다 관리할 책임을 가지고있다.

미리 정의해둔 ActorMessage를 보내서 특정 동작을 유도할수있다.

## 충돌처리

캐릭터충돌,탄막등의 충돌처리는 2D충돌체로 처리한다.

Collider2DManager는 충돌을 담당하는 클래스로, 여기에 등록한 Collider는 충돌 계산에 참여할 수 있다.

IActorCollider는 Actor의 충돌판정을 받을 충돌체를 나타내며, IActorCollider와의 충돌을 검사한다. IActorTrigger는 Actor의 트리거를 나타내며, IActorCollider와의 충돌을 검사한다.

Actor는 생성,파괴시 2DCollider를 생성,파괴할 책임이 있다.

Collider의 Transform값을 변경해도 물리연산단계 전까지 실제로 업데이트가 되지않는 문제가 존재한다.Physics2D.autoSyncTransforms를 True로 설정하거나 수동으로 syncTransform을 호출하여 해결할 수 있다.
<br />
<br />
<br />
캐릭터는 경기장 바깥으로 나가서는 안된다. 단순충돌처리로는 캐릭터가 존재가능한 올바른 위치가 어디인지 찾아내는것은 힘들다.

캐릭터가 벽안에 존재하는지 바깥에 존재하는지 검사할 방법으로 NavMesh를 사용했다.

Bake된 NavmeshData는 캐릭터가 존재할수있는 영역을 정의한다. Navmesh를 통해 가장 가까운 이동할수 있는 위치도 쉽게 찾을 수 있다.
<br />
<br />
<br />
캐릭터간 영역이 겹치지 않도록 하는것은 어렵다.

최종적으로 겹치지 않아야하는 오브젝트도 충돌판정을 위해 잠깐 겹쳐야하고, 충돌을 해결한 다음 다른 충돌이 생길수도 있다.

충돌 해결단계를 여러번 실행해 충돌할 가능성을 최소화 하지만 언제나 겹친 오브젝트는 발생 할 수 있다.


## 캐릭터 제어

캐릭터는 Charaterbase를 상속받은 클래스로 표현된다.

Controller클래스가 사용자 Input을 캐릭터의 특정 동작으로 매핑하여 전달하면 Character는 적절한 동작을 수행한다.

캐릭터는 전투관련 데이터를 가지고있으며, CombatSystem클래스를 통해 공격하거나, 공격받을 수 있다.

서버의 Actor데이터를 전송받을때 Action,Func같은 대리자를 전송할 수 없기에 콜백을 사용하지 않기로했다. 따라서 AttackCheck,ApplyDamage같은 메서드를 직접 작성하는 등, 다른 표현방법이 필요하다.

캐릭터의 상태에 따라 입력에 대한 동작이 달라질 수 있다. 캐릭터의 상태를 표현하기위해 스테이트머신을 구현하기로 했다. 현재 캐릭터가 무슨 상태에 존재하는지 명확하게 구분 할 수 있으며, 상태에 따라 다른 동작을 정의할 수 있다. 또한 다른 상태로 쉽게 전이가 가능하다.
<br />
<br />
<br />
gameobject클래스는 계산된 서버위치로 순간이동하는 것처럼 보이지 않도록 그 위치를 저장해두었다가 보간한다.

플레이어가 컨트롤하는 캐릭터는 플레이어입력을 저장해두었다가 서버데이터를 기반으로 시뮬레이트해 통신지연을 숨긴다.

CharacterBase클래스와 별개로 예측에 사용할 내부스테이트 머신을 가지고있다. 이를 사용해 플레이어의 입력에 대한 동작을 예측할 수 있다.
<br />
<br />
<br />
Buff시스템은 고려해야하는 상황이 많아 크게 네가지로 분류한다.

스탯 변경:캐릭터의 이동속도 증가,감소같은 효과

캐릭터 제어: 기절 등의 캐릭터 조작에 영향을 주는 효과

틱 업데이트: 도트데미지,점점 느려지는 슬로우 등의 효과

전투시스템 조작: 무적,반격 등의 효과

각 클래스들을 상속받아 원하는 효과를 추가할 수 있다.


